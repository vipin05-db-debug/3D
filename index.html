<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled 3D Particles - Laptop Cam</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Mirror the video so it feels natural interaction */
        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 2;
            width: 240px; height: 180px; border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(0, 255, 204, 0.3); transform: scaleX(-1);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        #ui {
            position: absolute; top: 30px; left: 30px; z-index: 3;
            color: white; pointer-events: none;
            text-shadow: 0 0 10px rgba(0,255,255,0.6);
        }
        h1 { margin: 0 0 10px 0; font-size: 1.8rem; letter-spacing: 3px; font-weight: 300; }
        .instruction { font-size: 1rem; color: #ccc; margin-bottom: 5px; display: flex; align-items: center; gap: 10px; }
        .highlight { color: #00ffcc; font-weight: bold; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-size: 1.5rem; z-index: 10; font-family: monospace;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Starting Camera & GPU...</div>

    <div id="ui">
        <h1>NEURAL CLOUD</h1>
        <div class="instruction">‚úã <span class="highlight">Move Open Hand</span> to Rotate Angle</div>
        <div class="instruction">‚ÜîÔ∏è <span class="highlight">Move Closer/Farther</span> to Zoom</div>
        <div class="instruction">ü§è <span class="highlight">Pinch Index+Thumb</span> to Compress</div>
        <div class="instruction">‚úä <span class="highlight">Make Fist</span> to Change Shape</div>
        <br>
        <div id="status" style="font-family: monospace; color: #888;">Waiting for hand...</div>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>
    <div id="canvas-container"></div>

<script>
    // --- 1. CONFIGURATION ---
    const PARTICLE_COUNT = 9000;
    const CAM_FOV = 75;
    
    // --- 2. STATE MANAGEMENT ---
    const state = {
        shapeIndex: 0,
        handPosition: new THREE.Vector3(0, 0, 0), // X, Y, Z (Depth)
        rawHandZ: 0, // Raw depth from camera
        isPinching: false,
        isFist: false,
        handDetected: false,
        shapeSwitchCooldown: 0,
        targetScale: 1.0,
        targetRotation: { x: 0, y: 0 }
    };

    // --- 3. THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.03);

    const camera = new THREE.PerspectiveCamera(CAM_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 12;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- 4. PARTICLE SYSTEM & TEXTURE ---
    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(200, 255, 255, 1)');
        gradient.addColorStop(0.2, 'rgba(0, 255, 200, 0.6)');
        gradient.addColorStop(0.5, 'rgba(0, 100, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
    }

    // Shapes
    function getSphere(count, r) {
        const arr = [];
        for(let i=0; i<count; i++) {
            const phi = Math.acos(-1 + (2 * i) / count);
            const theta = Math.sqrt(count * Math.PI) * phi;
            arr.push(r * Math.cos(theta) * Math.sin(phi), r * Math.sin(theta) * Math.sin(phi), r * Math.cos(phi));
        }
        return arr;
    }
    
    function getCube(count, size) {
        const arr = [];
        for(let i=0; i<count; i++) {
            arr.push((Math.random()-0.5)*size, (Math.random()-0.5)*size, (Math.random()-0.5)*size);
        }
        return arr;
    }

    function getTorus(count, R, r) {
        const arr = [];
        for(let i=0; i<count; i++) {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            arr.push(
                (R + r * Math.cos(v)) * Math.cos(u),
                (R + r * Math.cos(v)) * Math.sin(u),
                r * Math.sin(v)
            );
        }
        return arr;
    }

    function getHelix(count) {
        const arr = [];
        for(let i=0; i<count; i++) {
            const t = i / 20;
            arr.push(
                Math.cos(t) * 3,
                (i - count/2) * 0.05,
                Math.sin(t) * 3
            );
        }
        return arr;
    }

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);

    // Initial setup
    const initialShape = getSphere(PARTICLE_COUNT, 5);
    for(let i=0; i<PARTICLE_COUNT*3; i++) {
        positions[i] = (Math.random()-0.5) * 50; // Exploded start
        targetPositions[i] = initialShape[i];
        colors[i] = 1;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.15,
        map: createGlowTexture(),
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // Shape Data
    const shapes = [
        getSphere(PARTICLE_COUNT, 5),
        getCube(PARTICLE_COUNT, 8),
        getTorus(PARTICLE_COUNT, 5, 1.5),
        getHelix(PARTICLE_COUNT)
    ];
    const shapeNames = ["Sphere", "Quantum Cube", "Torus Field", "Double Helix"];

    function nextShape() {
        state.shapeIndex = (state.shapeIndex + 1) % shapes.length;
        const newPos = shapes[state.shapeIndex];
        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            targetPositions[i] = newPos[i];
        }
        document.getElementById('status').innerHTML = `Transformed to: <span class="highlight">${shapeNames[state.shapeIndex]}</span>`;
    }

    // --- 5. VISION & GESTURE LOGIC (MediaPipe) ---
    const videoElement = document.getElementById('input_video');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            state.handDetected = true;
            const landmarks = results.multiHandLandmarks[0];

            // --- A. Position & Angle (Open Hand) ---
            // Map hand X/Y to Rotation Angles
            // Landmarks[9] is the middle finger knuckle (central point)
            const centerX = (0.5 - landmarks[9].x) * 2; // -1 to 1
            const centerY = (0.5 - landmarks[9].y) * 2; // -1 to 1
            
            state.targetRotation.y = centerX * 2.5; // Rotate Y axis based on Hand X
            state.targetRotation.x = centerY * 2.5; // Rotate X axis based on Hand Y

            // --- B. Zoom (Depth) ---
            // Calculate scale based on apparent hand size or wrist depth. 
            // We use distance between wrist(0) and Middle Finger MCP(9) as a stable size reference.
            const wrist = landmarks[0];
            const middleMCP = landmarks[9];
            const handSize = Math.sqrt(
                Math.pow(wrist.x - middleMCP.x, 2) + 
                Math.pow(wrist.y - middleMCP.y, 2)
            );
            
            // Typical hand size is 0.1 (far) to 0.3 (close). Map this to Scale.
            // Zoom: If hand is huge (close), scale up.
            state.targetScale = 0.5 + (handSize * 5); // Base scale 0.5, adds zoom factor

            // --- C. Pinch (Compress) ---
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const pinchDist = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            state.isPinching = pinchDist < 0.05;

            // --- D. Fist (Switch Shape) ---
            // Check if fingertips are lower than knuckles (folded in)
            const tips = [landmarks[8], landmarks[12], landmarks[16], landmarks[20]]; // Index, Mid, Ring, Pinky
            const knuckles = [landmarks[5], landmarks[9], landmarks[13], landmarks[17]];
            
            // Simple fist logic: are tips close to the wrist?
            const tipToWristDist = Math.sqrt(Math.pow(landmarks[12].x - wrist.x, 2) + Math.pow(landmarks[12].y - wrist.y, 2));
            state.isFist = tipToWristDist < 0.15; 

            if(!state.isPinching && !state.isFist) {
                 document.getElementById('status').innerText = "Status: Rotating & Zooming";
            } else if (state.isPinching) {
                document.getElementById('status').innerText = "Status: Compressing";
            }

        } else {
            state.handDetected = false;
            // Reset slowly if hand lost
            state.targetScale = 1;
            state.targetRotation.x = 0;
            state.targetRotation.y = 0;
            document.getElementById('status').innerText = "Status: Waiting for hand...";
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    // Use default camera (Laptop Webcam)
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();

    // --- 6. ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();
        const positionsAttr = geometry.attributes.position;
        const colorsAttr = geometry.attributes.color;

        // Shape Switcher Cooldown
        if(state.isFist && state.shapeSwitchCooldown <= 0) {
            nextShape();
            state.shapeSwitchCooldown = 2.0; // 2 Seconds delay
        }
        if(state.shapeSwitchCooldown > 0) state.shapeSwitchCooldown -= delta;

        // Smoothly Interpolate Global Rotation & Scale
        if(state.handDetected) {
            particles.rotation.x += (state.targetRotation.x - particles.rotation.x) * 0.1;
            particles.rotation.y += (state.targetRotation.y - particles.rotation.y) * 0.1;
            
            // Apply scale
            const currentScale = particles.scale.x;
            const newScale = currentScale + (state.targetScale - currentScale) * 0.1;
            particles.scale.set(newScale, newScale, newScale);
        } else {
            // Auto rotate if no hand
            particles.rotation.y += 0.002;
            // Reset scale
            particles.scale.lerp(new THREE.Vector3(1,1,1), 0.05);
        }

        // Particle Physics
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3; const iy = i*3+1; const iz = i*3+2;

            let tx = targetPositions[ix];
            let ty = targetPositions[iy];
            let tz = targetPositions[iz];

            // Gesture: PINCH (Compress to center)
            if(state.isPinching) {
                tx *= 0.1; 
                ty *= 0.1; 
                tz *= 0.1;
            }

            // Move particles toward target (Morphing)
            positionsAttr.array[ix] += (tx - positionsAttr.array[ix]) * 0.1;
            positionsAttr.array[iy] += (ty - positionsAttr.array[iy]) * 0.1;
            positionsAttr.array[iz] += (tz - positionsAttr.array[iz]) * 0.1;

            // Color: Pulse based on time + position
            const hue = (i/PARTICLE_COUNT * 0.5 + time * 0.1) % 1;
            const color = new THREE.Color();
            
            if(state.isPinching) {
                // Turn Red when pinching
                color.setHSL(0.0, 1.0, 0.5); 
            } else if (state.isFist) {
                // Turn Purple when switching
                color.setHSL(0.8, 1.0, 0.5);
            } else {
                // Normal Cyan/Blue
                color.setHSL(0.5 + hue * 0.2, 0.8, 0.6);
            }

            colorsAttr.array[ix] = color.r;
            colorsAttr.array[iy] = color.g;
            colorsAttr.array[iz] = color.b;
        }

        positionsAttr.needsUpdate = true;
        colorsAttr.needsUpdate = true;
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>