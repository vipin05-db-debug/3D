<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neural Cloud v2 - Advanced Gestures</title>
    <style>
        body { margin: 0; overflow: hidden; background: #010409; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 2;
            width: 200px; height: 150px; border-radius: 12px; overflow: hidden;
            border: 2px solid #00f2ff; transform: scaleX(-1); opacity: 0.7;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui {
            position: absolute; top: 30px; left: 30px; z-index: 3;
            color: white; pointer-events: none; text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        .instruction { font-size: 0.9rem; color: #aaa; margin-bottom: 8px; }
        .highlight { color: #00f2ff; font-weight: bold; }
        #status-box { background: rgba(0,0,0,0.5); padding: 10px; border-left: 3px solid #00f2ff; margin-top: 15px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00f2ff; font-family: monospace; z-index: 10; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">SYNCHRONIZING NEURAL INTERFACE...</div>

    <div id="ui">
        <h1 style="letter-spacing: 5px; font-weight: 200; margin:0;">CORE_GEOMETRY</h1>
        <div id="status-box">
            <div class="instruction">‚úã <span class="highlight">OPEN HAND</span> - Rotate Object</div>
            <div class="instruction">ü§è <span class="highlight">PINCH & SLIDE UP/DN</span> - Zoom In/Out</div>
            <div class="instruction">‚úä <span class="highlight">FIST</span> - Cycle 10 Shapes</div>
        </div>
        <br>
        <div id="shape-name" style="font-size: 1.2rem; color: #00f2ff;">Shape: Sphere</div>
    </div>

    <div id="video-container"><video id="input_video"></video></div>
    <div id="canvas-container"></div>

<script>
    const PARTICLE_COUNT = 12000;
    const state = {
        shapeIndex: 0,
        isPinching: false,
        isFist: false,
        handDetected: false,
        shapeSwitchCooldown: 0,
        zoomLevel: 1.0,
        lastPinchY: null,
        targetRotation: { x: 0, y: 0 }
    };

    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- SHAPE GENERATORS (10 UNIQUE MODELS) ---
    function getSphere(c) {
        const a = []; for(let i=0; i<c; i++) {
            const phi = Math.acos(-1 + (2 * i) / c), theta = Math.sqrt(c * Math.PI) * phi;
            a.push(6 * Math.cos(theta) * Math.sin(phi), 6 * Math.sin(theta) * Math.sin(phi), 6 * Math.cos(phi));
        } return a;
    }
    function getCube(c) {
        const a = []; for(let i=0; i<c; i++) a.push((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10); return a;
    }
    function getTorus(c) {
        const a = []; for(let i=0; i<c; i++) {
            const u = Math.random()*Math.PI*2, v = Math.random()*Math.PI*2;
            a.push((6+2*Math.cos(v))*Math.cos(u), (6+2*Math.cos(v))*Math.sin(u), 2*Math.sin(v));
        } return a;
    }
    function getDNA(c) {
        const a = []; for(let i=0; i<c; i++) {
            const t = (i/c) * Math.PI * 10;
            const side = i % 2 === 0 ? 1 : -1;
            a.push(Math.cos(t)*3*side, t*1.5 - 7.5, Math.sin(t)*3*side);
        } return a;
    }
    function getPyramid(c) {
        const a = []; for(let i=0; i<c; i++) {
            const h = Math.random() * 10 - 5;
            const s = (5 - h) * 0.8;
            const face = Math.floor(Math.random()*4);
            let x, z;
            if(face==0) { x=s; z=(Math.random()*2-1)*s; }
            else if(face==1) { x=-s; z=(Math.random()*2-1)*s; }
            else if(face==2) { z=s; x=(Math.random()*2-1)*s; }
            else { z=-s; x=(Math.random()*2-1)*s; }
            a.push(x, h, z);
        } return a;
    }
    function getCylinder(c) {
        const a = []; for(let i=0; i<c; i++) {
            const t = Math.random()*Math.PI*2, h = Math.random()*12-6;
            a.push(Math.cos(t)*5, h, Math.sin(t)*5);
        } return a;
    }
    function getHyperboloid(c) {
        const a = []; for(let i=0; i<c; i++) {
            const v = Math.random()*Math.PI*2, u = Math.random()*6-3;
            const r = 2 * Math.sqrt(1 + u*u);
            a.push(r*Math.cos(v), u*3, r*Math.sin(v));
        } return a;
    }
    function getRose(c) {
        const a = []; for(let i=0; i<c; i++) {
            const t = (i/c) * Math.PI * 2;
            const r = 6 * Math.sin(4 * t);
            a.push(r*Math.cos(t), r*Math.sin(t), (Math.random()-0.5)*2);
        } return a;
    }
    function getCapsule(c) {
        const a = []; for(let i=0; i<c; i++) {
            const t = Math.random()*Math.PI*2, h = Math.random()*8-4;
            const r = 4;
            a.push(Math.cos(t)*r, h, Math.sin(t)*r);
        } return a;
    }
    function getStar(c) {
        const a = []; for(let i=0; i<c; i++) {
            const t = Math.random()*Math.PI*2, r = (i%2==0?7:3) * Math.random();
            a.push(r*Math.cos(t), r*Math.sin(t), (Math.random()-0.5)*5);
        } return a;
    }

    const shapeGenerators = [getSphere, getCube, getTorus, getDNA, getPyramid, getCylinder, getHyperboloid, getRose, getCapsule, getStar];
    const shapeNames = ["Biosphere", "Data Cube", "Torus Core", "Neural DNA", "Monolith", "Flux Cylinder", "Wormhole", "Quantum Rose", "Capsule", "Supernova"];
    
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);

    const initialPos = shapeGenerators[0](PARTICLE_COUNT);
    for(let i=0; i<PARTICLE_COUNT*3; i++) {
        positions[i] = initialPos[i];
        targetPositions[i] = initialPos[i];
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.1, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- VISION LOGIC ---
    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            state.handDetected = true;
            const lm = results.multiHandLandmarks[0];

            // Rotation (Middle Knuckle)
            state.targetRotation.y = (0.5 - lm[9].x) * 4;
            state.targetRotation.x = (0.5 - lm[9].y) * 4;

            // Pinch Detection (Thumb Tip + Index Tip)
            const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            const isPinchingNow = pinchDist < 0.04;

            // Better Zoom: Pinch & Move Y
            if(isPinchingNow) {
                if(state.lastPinchY !== null) {
                    const movementY = state.lastPinchY - lm[8].y;
                    state.zoomLevel += movementY * 5; // Sensitivity
                    state.zoomLevel = Math.max(0.2, Math.min(state.zoomLevel, 3.0));
                }
                state.lastPinchY = lm[8].y;
                state.isPinching = true;
            } else {
                state.lastPinchY = null;
                state.isPinching = false;
            }

            // Fist Detection (Switch Shape)
            const fistDist = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);
            state.isFist = fistDist < 0.12;
        } else {
            state.handDetected = false;
        }
    }

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
    hands.onResults(onResults);

    const videoElement = document.getElementById('input_video');
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // Handle Shape Switching
        if(state.isFist && state.shapeSwitchCooldown <= 0) {
            state.shapeIndex = (state.shapeIndex + 1) % shapeGenerators.length;
            const nextData = shapeGenerators[state.shapeIndex](PARTICLE_COUNT);
            for(let i=0; i<PARTICLE_COUNT*3; i++) targetPositions[i] = nextData[i];
            document.getElementById('shape-name').innerText = `Shape: ${shapeNames[state.shapeIndex]}`;
            state.shapeSwitchCooldown = 1.5;
        }
        if(state.shapeSwitchCooldown > 0) state.shapeSwitchCooldown -= delta;

        // Apply Zoom & Rotation
        particles.scale.lerp(new THREE.Vector3(state.zoomLevel, state.zoomLevel, state.zoomLevel), 0.1);
        if(state.handDetected) {
            particles.rotation.x += (state.targetRotation.x - particles.rotation.x) * 0.1;
            particles.rotation.y += (state.targetRotation.y - particles.rotation.y) * 0.1;
        } else {
            particles.rotation.y += 0.005;
        }

        // Morph Particles
        const posAttr = geometry.attributes.position;
        const colAttr = geometry.attributes.color;
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i*3;
            posAttr.array[i3] += (targetPositions[i3] - posAttr.array[i3]) * 0.08;
            posAttr.array[i3+1] += (targetPositions[i3+1] - posAttr.array[i3+1]) * 0.08;
            posAttr.array[i3+2] += (targetPositions[i3+2] - posAttr.array[i3+2]) * 0.08;

            // Color Pulse
            const color = new THREE.Color();
            if(state.isPinching) color.setHSL(0.5, 1, 0.5); // Cyan when zooming
            else color.setHSL((state.shapeIndex * 0.1 + time * 0.05) % 1, 0.8, 0.6);
            
            colAttr.array[i3] = color.r;
            colAttr.array[i3+1] = color.g;
            colAttr.array[i3+2] = color.b;
        }
        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
